package org.matsim.core.mobsim.qsim.qnetsimengine;

import fastOrForcedToFollow.Cyclist;
import fastOrForcedToFollow.configgroups.FFFConfigGroup;

import org.matsim.api.core.v01.Id;
import org.matsim.api.core.v01.TransportMode;
import org.matsim.api.core.v01.network.Link;
import org.matsim.api.core.v01.population.Person;
import org.matsim.core.mobsim.framework.DriverAgent;
import org.matsim.core.mobsim.framework.HasPerson;
import org.matsim.core.mobsim.framework.MobsimDriverAgent;
import org.matsim.core.mobsim.framework.PassengerAgent;
import org.matsim.vehicles.Vehicle;
import org.matsim.vehicles.VehicleType;
import org.matsim.vehicles.VehicleUtils;

import java.util.Collection;

/**
 * The {@link this.qVehicle} is the thing that is passed from one link through the other, via {@link QNodeI}.  (The cycle plugin here replaces only
 *  the {@link QLinkI}.)  So we wrap the cycle dynamics (essentially generated by the {@link Cyclist}) a {@link this.qVehicle}, and make it available every
 *  time we have traversed a {@link QNodeI}, and just entered a new link.  We also use a {@link this.qVehicleImpl} as delegate for all methods which
 *  are not implemented by {@link Cyclist}.
 */
public class QCycle implements QVehicle
{

	private QVehicle qVehicle  ;
	private Cyclist cyclist ;
	
	
	/**
	 * Creates a QCycleAsVehicle based on the basicVehicle inputted. Cyclist is created later on, when the driver is set, i.e. in {@link #setDriver(DriverAgent)}
	 * @param basicVehicle
	 */
	public QCycle( Vehicle basicVehicle ) {
		VehicleType vehicleType = VehicleUtils.getFactory().createVehicleType(Id.create(basicVehicle.getId().toString(), VehicleType.class));
		vehicleType.setNetworkMode(TransportMode.bike);
		Vehicle vehicle = VehicleUtils.getFactory().createVehicle(Id.createVehicleId(basicVehicle.getId().toString()), vehicleType);
		this.qVehicle = new QVehicleImpl(vehicle);
		
//		this.qVehicle = new QVehicleImpl( basicVehicle ) ;
	}
	
	
	/**
	 * Sets the driver and internally creates the cyclist based on the person being the driver.
	 */
	@Override public void setDriver( final DriverAgent driver ) {
		this.qVehicle.setDriver( driver );
		if ( driver!=null ){   // is null when vehicle arrives, and driver LEAVES vehicle!
			Person person = ((HasPerson) driver).getPerson();
			final double v_0 = (double) person.getAttributes().getAttribute( FFFConfigGroup.DESIRED_SPEED );
			final double theta_0 = (double) person.getAttributes().getAttribute( FFFConfigGroup.HEADWAY_DISTANCE_INTERCEPT );
			final double theta_1 = (double) person.getAttributes().getAttribute( FFFConfigGroup.HEADWAY_DISTANCE_SLOPE );
			final double lambda_c = (double) person.getAttributes().getAttribute( FFFConfigGroup.BICYCLE_LENGTH );
			this.cyclist = Cyclist.createIndividualisedCyclistWithSqrtLTM(v_0, theta_0, theta_1, lambda_c);
			this.qVehicle.getVehicle().getType().setMaximumVelocity(v_0);
	         
		}

	}
	
	
	public Cyclist getCyclist() {
		return this.cyclist;
	}
	
	public QVehicle getQVehicle() {
		return this.qVehicle;
	}
	
	@Override public double getEarliestLinkExitTime() {
		//Uses cyclist's value
		return this.cyclist.getTEarliestExit();
	}
	
	@Override public void setEarliestLinkExitTime( final double tEarliestExit ) {
		//Uses cyclist's value
		this.cyclist.setTEarliestExit(tEarliestExit);
	}


	@Override public double getLinkEnterTime() {
        return this.qVehicle.getLinkEnterTime();
	}
	
	@Override public void setLinkEnterTime( final double linkEnterTime ) {
       this.qVehicle.setLinkEnterTime(linkEnterTime);
	}
	
	@Override public double getMaximumVelocity() {
		//Uses cyclist's value;
		return this.cyclist.getDesiredSpeed();
	}
	
	@Override public double getSizeInEquivalents() {
		return this.qVehicle.getSizeInEquivalents();
	}
	
	@Override public Vehicle getVehicle() {
		return this.qVehicle.getVehicle();
	}
	
	@Override public MobsimDriverAgent getDriver() {
		return this.qVehicle.getDriver();
	}
	
	@Override public Id<Vehicle> getId() {
		return this.qVehicle.getId();
	}
	
	@Override public Link getCurrentLink() {
		return this.qVehicle.getCurrentLink();
	}
	
	@Override public boolean addPassenger( final PassengerAgent passenger ) {
		return this.qVehicle.addPassenger( passenger );
	}
	
	@Override public boolean removePassenger( final PassengerAgent passenger ) {
		return this.qVehicle.removePassenger( passenger );
	}
	
	@Override public Collection<? extends PassengerAgent> getPassengers() {
		return this.qVehicle.getPassengers();
	}
	
	@Override public int getPassengerCapacity() {
		return this.qVehicle.getPassengerCapacity();
	}
	
	@Override public void setCurrentLink( final Link link ) {
		this.qVehicle.setCurrentLink( link );
	}

	
	
}
